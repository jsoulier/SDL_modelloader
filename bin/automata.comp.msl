#pragma clang diagnostic ignored "-Wmissing-prototypes"
#pragma clang diagnostic ignored "-Wmissing-braces"

#include <metal_stdlib>
#include <simd/simd.h>

using namespace metal;

template<typename T, size_t Num>
struct spvUnsafeArray
{
    T elements[Num ? Num : 1];
    
    thread T& operator [] (size_t pos) thread
    {
        return elements[pos];
    }
    constexpr const thread T& operator [] (size_t pos) const thread
    {
        return elements[pos];
    }
    
    device T& operator [] (size_t pos) device
    {
        return elements[pos];
    }
    constexpr const device T& operator [] (size_t pos) const device
    {
        return elements[pos];
    }
    
    constexpr const constant T& operator [] (size_t pos) const constant
    {
        return elements[pos];
    }
    
    threadgroup T& operator [] (size_t pos) threadgroup
    {
        return elements[pos];
    }
    constexpr const threadgroup T& operator [] (size_t pos) const threadgroup
    {
        return elements[pos];
    }
};

struct uniformRules
{
    uint survival;
    uint birth;
    uint state;
    uint neighborhood;
    uint frame;
};

constant uint3 gl_WorkGroupSize [[maybe_unused]] = uint3(8u);

constant spvUnsafeArray<int3, 26> _82 = spvUnsafeArray<int3, 26>({ int3(-1), int3(0, -1, -1), int3(1, -1, -1), int3(-1, 0, -1), int3(0, 0, -1), int3(1, 0, -1), int3(-1, 1, -1), int3(0, 1, -1), int3(1, 1, -1), int3(-1, -1, 0), int3(0, -1, 0), int3(1, -1, 0), int3(-1, 0, 0), int3(1, 0, 0), int3(-1, 1, 0), int3(0, 1, 0), int3(1, 1, 0), int3(-1, -1, 1), int3(0, -1, 1), int3(1, -1, 1), int3(-1, 0, 1), int3(0, 0, 1), int3(1, 0, 1), int3(-1, 1, 1), int3(0, 1, 1), int3(1) });
constant spvUnsafeArray<int3, 6> _132 = spvUnsafeArray<int3, 6>({ int3(-1, 0, 0), int3(1, 0, 0), int3(0, -1, 0), int3(0, 1, 0), int3(0, 0, -1), int3(0, 0, 1) });

kernel void main0(constant uniformRules& _31 [[buffer(0)]], texture3d<uint> inCells [[texture(0)]], texture3d<uint, access::write> outCells [[texture(1)]], uint3 gl_GlobalInvocationID [[thread_position_in_grid]])
{
    int3 id = int3(gl_GlobalInvocationID);
    if (any(id >= int3(128)))
    {
        return;
    }
    uint neighbors = 0u;
    switch (_31.neighborhood)
    {
        case 0u:
        {
            for (int i = 0; i < 26; i++)
            {
                int3 neighborId = id + _82[i];
                bool _92 = any(neighborId < int3(0));
                bool _99;
                if (!_92)
                {
                    _99 = any(neighborId >= int3(128));
                }
                else
                {
                    _99 = _92;
                }
                if (_99)
                {
                    continue;
                }
                neighbors += uint(inCells.read(uint3(neighborId)).x > 0u);
            }
            break;
        }
        case 1u:
        {
            for (int i_1 = 0; i_1 < 6; i_1++)
            {
                int3 neighborId_1 = id + _132[i_1];
                bool _141 = any(neighborId_1 < int3(0));
                bool _148;
                if (!_141)
                {
                    _148 = any(neighborId_1 >= int3(128));
                }
                else
                {
                    _148 = _141;
                }
                if (_148)
                {
                    continue;
                }
                neighbors += uint(inCells.read(uint3(neighborId_1)).x > 0u);
            }
            break;
        }
    }
    int count = int(inCells.read(uint3(id)).x);
    if (neighbors != _31.survival)
    {
        count--;
    }
    if (neighbors == _31.birth)
    {
        count = int(_31.state);
    }
    count = max(0, count);
    outCells.write(uint4(uint(count)), uint3(id));
}

